# README 撰写原则与风格说明

本文件用于记录当前仓库中 README（尤其是主 README.md）在撰写和维护时应遵循的要求与风格特征，便于后续修改时保持一致性。

---

## 一、总的目标

- 面向“阅读代码的人”，而不是面向“写代码的人”：优先解释功能和流程，再给出具体函数和变量名。
- 读者不需要打开代码文件，也能大致弄清楚每一步在做什么、输入输出是什么、顺序关系如何。
- 代码名和路径主要作为“可快速搜索的索引信息”，统一放在括号或专门条目中。

---

## 二、描述风格的核心原则

### 1. 先“人话”，后“名词”

- 所有说明优先用自然语言描述“在做什么、为什么”，然后再补充函数名、变量名等技术细节。
- 规则：
  - 功能放在前半句，用完整中文句子。
  - 具体的函数名、变量名、参数名放在句尾的括号或方括号中，用于“精确定位”。
- 示例：
  - `utils.py 负责返回带 LOCAL_TZ 的当前本地时间【now_local()】`
  - `config.py 负责提供机构搜索关键词列表（ORG_SEARCH_TERMS）、机构匹配规则（INSTITUTIONS_PATTERNS）以及 per-org 搜索分页参数（PER_ORG_SEARCH_LIMIT_PAGES、PER_ORG_SEARCH_PAGE_SIZE）`

### 2. 函数名与变量名的书写规则

- 函数名：
  - 在说明中称为“某个功能”，而不是直接当成句子主语。
  - 出现形式：先写“主题判断函数”“机构识别函数”等，再在括号或方括号里给出具体函数名。
  - 示例：
    - `负责实现基于正则的主题判断函数，用于判断论文是否命中目标主题（is_target_topic）`
    - `用于处理单个 JSON 文件并触发后续拷贝与摘要逻辑【on_json、job（app2.py#L213-L256）】`
- 变量名 / 配置名：
  - 先说明“它代表什么含义”，再在括号中给出具体变量名。
  - 示例：
    - `机构搜索关键词列表（ORG_SEARCH_TERMS）`
    - `主题包含规则列表，用于判断“想要哪些类型的论文”（TOPIC_INCLUDE_PATTERNS）`
    - `大模型机构识别系统提示词（org_system_prompt）`
- 文件路径：
  - 文件或文件夹路径可以直接出现在说明中，不需要放在括号中。
  - 示例：`data/json/YYYY-MM-DD/*.json`、`dataSelect/summary/YYYY-MM-DD/`。

### 3. 步骤式流程描述

- 对于主流程（如 app2.py），统一采用“分步骤 + 文本代码块”的形式：
  - 先用“1. 2. 3.”编号说明步骤名称与核心含义。
  - 每一步下面用一个 ```text 代码块，内部再细化为若干小节。
- 每个步骤通常包含以下结构（可按需要增减）：
  - “对应代码文件”：列出涉及的文件 + 中文说明 + 括号/方括号中的具体名。
  - “主要函数”：列出关键函数及其所在文件行号。
  - “入口代码片段”：说明从哪个函数/行号进入这一逻辑。
  - “输入 / 输出”：写明输入的路径、格式和来源，以及输出的路径和用途。
  - “并发说明 / 触发时机”：解释并发策略或回调触发方式。
- 示例结构：

```text
3. 构建候选论文列表（基线 + 直搜补齐）：先按 cs./stat.ML 拉取近期论文作为基线，再对缺失机构做 per-org 直搜补齐并合并去重（内部有多线程并发执行）

    对应代码文件：
        - app2.py 负责在给定时间窗口内先收集一批“最近论文”的基础列表，作为后续筛选与补充搜索的起点，并根据配置决定是否对部分或全部机构再执行一次按机构关键字的补充搜索（FILL_MISSING_BY_ORG、ALWAYS_PER_ORG_SEARCH）
        - fetch_arxiv.py 负责封装 arXiv API：先按分类拉取近期论文列表（iter_recent_cs），再按机构关键词做 per-org 搜索以补齐特定机构的论文（search_by_terms）
        - ...
    主要函数：
        - _collect_baseline_entries（app2.py#L38-L51）
        - build_candidates_with_fallback（app2.py#L54-L106）
    输入：
        - 上一步生成的时间窗口（start_utc, end_utc）与配置中的机构搜索参数
    输出：
        - 候选论文条目列表，用于后续缓存 PDF 与主题过滤
```

---

## 三、输入输出与路径说明

### 1. 必须显式写出输入和输出

- 每个“重 IO”的步骤（下载 PDF、MinerU 解析、机构识别、摘要输出等）都需要在 README 中显式写出：
  - 输入来自哪里（上一步的哪种文件、路径模式）。
  - 输出写到哪里（目录结构、文件命名规则）。
- 典型说明方式：
  - `输入：`
    - `PDF 输入：PDF_CACHE_DIR/YYYY-MM-DD/*.pdf（由步骤 5 缓存得到的全部 PDF 列表，经 limit-files 截断）`
  - `输出：`
    - `输出 data/md ：论文经过解析后的 md 格式原文件（data/md/YYYY-MM-DD/*.md）`
    - `输出 data/json ：论文经过解析后的 json 格式原文件（data/json/YYYY-MM-DD/*.json），同时作为 on_json 回调的输入`

### 2. 指出“触发时机”和“批处理策略”

- 对于有“回调”和“分批处理”的步骤，需要写明：
  - 先做哪一步，再触发哪一步。
  - 是“每个文件生成后立即处理”，还是“所有文件生成完之后统一处理”。
- 示例：
  - `先完成所有候选 PDF 的本地缓存（步骤 5），得到完整的 pdfs 列表`
  - `然后一次性将 pdfs 列表传入 run_local_batch，由 MinerU 以“小批次”方式按 batch_size 逐批处理`
  - `每处理完一批，就为这一批中的每个 PDF 写出对应的 md/json 文件，并立即触发 on_json 回调，而不是等所有批次全部完成后再统一触发`

---

## 四、并发与回调的说明方式

### 1. 并发策略

- 不直接说“调用某某线程池”，而是用业务语言描述“同时处理多个任务”。
- 同时在括号或专门条目中给出涉及的类和参数名。
- 示例：
  - `使用线程池按 decide-concurrency 指定的并发度同时处理多个 JSON 文件，run_local_batch 每生成一个 JSON 就提交一个机构识别任务【ThreadPoolExecutor、decide-concurrency】`
  - `main 中通过 org-search-concurrency 参数设置 per-org 搜索的并发线程数（build_candidates_with_fallback._org_search_concurrency）`

### 2. 回调（on_json）相关说明

- 不直接用“on_json/job”这种内部写法做主语，而是：
  - 用“机构识别与决定文件写入”“大机构论文的拷贝与摘要生成”等中文标题命名步骤。
  - 在正文解释“什么时候调用”“调用时做什么”。
  - 仅在括号或方括号中提示内部函数名，以便查找。
- 示例：
  - `每当 MinerU 在第 7 步为某个 PDF 写出一个 JSON 文件时，就会立即调用一个“机构识别 + 决策更新”的回调函数，对这篇论文做机构判断并更新决定文件【on_json】`
  - `处理单个机构识别结果并执行拷贝与摘要生成的回调逻辑【on_json、job（app2.py#L220-L253）】`

---

## 五、配置与模型说明的写法

### 1. 配置文件说明（以 configDepositary 为例）

- 说明顺序：
  - 先说明用户需要做的操作（复制、重命名、填哪些必填字段）。
  - 再按类别说明各配置项的含义，并给出变量名。
- 示例：

```markdown
**config/configDepositary.py**

将 config copy 文件夹名称中的 copy 去掉，然后补充 configDepositary.py 文件中的 minerU_Token 和 qwen_api_key 两个参数的值

- minerU_Token 可以去 ... 中创建（MinerU 接口的访问令牌，用于第 7 步 PDF→MD/JSON 解析【minerU_Token】）
- qwen_api_key 可以去 ... 中创建（Qwen 大模型的 API Key，用于机构识别与摘要生成【qwen_api_key】）
- 机构识别模型配置：包括机构识别所用的大模型接口地址和模型名称，影响第 8 步“机构识别与决定文件写入”以及独立运行的 json2decide.py【org_base_url、org_model】
- 摘要生成模型配置：包括摘要生成所用的大模型接口地址和模型名称，影响第 9 步“大机构论文拷贝 + 摘要生成”以及独立运行的 pdfSummary.py【summary_base_url、summary_model】
- 提示词配置：集中管理机构识别和摘要生成使用的系统提示词和可选用户前缀，控制输出风格与内容结构【system_prompt、user_prompt、org_system_prompt】
```

### 2. 参数表说明

- 对命令行参数使用标准表格形式：
  - 列：参数名称 / 值类型 / 默认值 / 说明。
  - 默认值要与代码保持一致。
- 示例：

|参数名称|值类型|默认值|说明|
|--|--|--|--|
|--limit-files|int|0|限制处理的 PDF 数量（0 表示不限）|
|--window-hours|int|0|时间窗口小时数；0 表示使用北京时间“昨天”窗口|
|--configdepositary|A/B|B|配置来源：A=文本文件，B=集中配置（config/configDepositary.py）|

---

## 六、链接代码位置的方式

- 使用“文件名 + 行号范围”的形式指向关键实现，帮助读者快速跳转。
- 写法统一为：`函数名（文件名#Lx-Ly）`，不在这里加入解释，解释放在前面的自然语言部分。
- 示例：
  - `main（app2.py#L108-L298）`
  - `run_local_batch（pdf2md.py#L215-L245）`
  - `load_first_pages_text（json2decide.py#L24-L43）`

---

## 七、语言与格式上的习惯

- 统一使用简体中文描述，英文仅用于：
  - 变量名、函数名、文件路径。
  - 特定术语（如 PDF、JSON、API）。
- 使用适量的空行，使段落和列表视觉上清晰，不将长说明挤在一行内。
- 解释一个概念时尽量保持“短句 + 分行”，避免出现过长的复合句。

---

## 八、后续修改时的检查清单

在修改或新增 README 内容时，建议自检以下几点：

1. 是否先用自然语言讲清楚“这一步在做什么、为什么”，再在括号或方括号中给出具体的函数名和变量名。
2. 是否为每个重要步骤写明了输入路径、输出路径，以及它们与前后步骤的关联。
3. 是否明确说明了并发策略或回调触发时机，而不是只写“调用某某函数”。
4. 是否对新增的配置项或参数解释了“含义 + 对应变量名”，而不仅仅列出名字。
5. 是否保持了现有的步骤结构（标题 + text 代码块）和参数表格式。
6. 是否避免在主说明中出现难以理解的内部名称（例如“on_json/job”），而是把它们放在括号或方括号中。

