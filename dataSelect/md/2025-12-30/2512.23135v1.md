# Beyond URDF: The Universal Robot Description Directory for Shared, Extensible, and Standardized Robot Models

Roshan Klein-Seetharaman and Daniel Rakita  
Department of Computer Science, Yale University  
{roshan.klein-seetharaman, daniel.rakita}@yale.edu

Abstract—Robots are typically described in software by specification files (e.g., URDF, SDF, MJCF, USD) that encode only basic kinematic, dynamic, and geometric information. As a result, downstream applications such as simulation, planning, and control must repeatedly re-derive richer data, leading to redundant computations, fragmented implementations, and limited standardization. In this work, we introduce the Universal Robot Description Directory (URDD), a modular representation that organizes derived robot information into structured, easy-to-parse JSON and YAML modules. Our open-source toolkit automatically generates URDDs from URDFs, with a Rust implementation supporting Bevy-based visualization. Additionally, we provide a JavaScript/Three.js viewer for web-based inspection of URDDs. Experiments on multiple robot platforms show that URDDs can be generated efficiently, encapsulate substantially richer information than standard specification files, and directly enable the construction of core robotics subroutines. URDD provides a unified, extensible resource for reducing redundancy and establishing shared standards across robotics frameworks. We conclude with a discussion on the limitations and implications of our work.

# I. INTRODUCTION

Robots are almost universally described in software by specification files (e.g., URDF, SDF, MJCF, USD) that define their structure and parameters. These files serve as the basis for downstream applications such as physics simulation, reinforcement learning, inverse kinematics, motion planning, model predictive control, and visualization. However, these specification files typically include only minimal, raw kinematic, dynamic, and geometric information. For instance, a URDF describes connectivity between links via joints (offsets, axes, limits), inertial properties of links, and optionally references mesh files for visual and collision geometry [10].

While such files provide a useful foundation, considerably more information must be derived downstream to support effective and convenient robotics development. A straightforward example is a robot's number of degrees of freedom: although critical for many applications, it is not specified directly in a URDF. Users must either manually count non-fixed, non-mimic joints or rely on external tools to compute it. More broadly, because specification files omit much of the information required for practical use, each downstream framework is forced to re-derive richer data from scratch, leading to redundancy, fragmented implementations, and a lack of shared, standardized resources.

In this work, we propose a new representation, the Universal Robot Description Directory (URDD), which organizes a rich set of robot information into a structured collection

of files, extending far beyond the minimal data captured in traditional specification formats. The URDD is composed of multiple subdirectories, called modules, each containing derived information about the robot stored in easy-to-parse JSON and YAML files. These modules are designed to capture extensive derived information required for downstream applications, reducing redundant code and enabling shared resources across different frameworks.

In addition to introducing the URDD representation, we provide open-source tools to automatically generate these directories for any robot. Our Rust-based implementation converts a robot's URDF into a URDD and includes visualization capabilities, built on the Bevy game engine, that allow users to inspect derived robot information onscreen and verify processed results. We also provide an open-source JavaScript tool, built with Three.js, that enables interactive visualization of URDD outputs directly in a web browser. $^{1}$

A URDD currently contains 15 modules, which are described throughout the paper. Example modules include: the DOF Module, which specifies the robot's number of DOFs and defines forward and inverse mappings between DOFs and joint indices; a Connections Module, which encodes the paths between every pair of links in the kinematic chain; and a Chain Module, which specifies the overall kinematic hierarchy of the robot, directly supporting the construction of a forward kinematics subroutine. Importantly, because the URDD is structured as a directory of sub-modules rather than a single specification file, additional modules can be incorporated over time without risking parsing errors in downstream implementations. In addition, each module in the URDD maintains a version tag, enabling outdated modules to be easily identified for updating or verification.

We demonstrate the effectiveness of our representation and tools by evaluating the timing and outputs of the URDF-to-URDD conversion process across three robot platforms. We further show that the resulting directories not only contain substantially more information than standard specification files but can also be directly leveraged, in both Rust and Python, to construct a forward kinematics function with only simple parsing code. Finally, we conclude with a discussion of limitations, potential extensions, and broader implications.

# II. RELATED WORKS

Robot description formats serve as the foundational layer for robotics software development, enabling simulation, plan-

ning, control, and visualization across diverse platforms. The Unified Robot Description Format (URDF) remains the most widely adopted standard for specifying robot kinematic hierarchies and geometry [10]. However, as robotics applications have grown in complexity, researchers have identified significant limitations in existing description formats and have proposed various extensions and alternatives.

# A. Robot Description Format Analysis and Extensions

Recent work has analyzed the usage patterns and limitations of URDF in practice. Tola and Corke [18, 17] conducted comprehensive studies examining URDF usage across robotics applications, identifying common issues and user experience challenges. Their analysis revealed that while URDF provides essential kinematic information, it lacks many derived properties needed for practical applications.

Several researchers have proposed extensions to address URDF's limitations. Chignoli et al. [3] introduced URDF+, which extends the format to support robots with kinematic loops, a significant limitation of the original specification. Similarly, Batto et al. [2] developed Extended URDF to account for parallel mechanisms in robot descriptions. These works highlight the ongoing need for richer robot representations that capture more complex kinematic structures.

While these extensions address specific structural limitations of URDF, they fundamentally differ from our approach in several key ways. First, these works extend the URDF specification itself, maintaining the monolithic XML format that requires parsing and processing by each downstream application. In contrast, URDD operates orthogonally to any base specification format: it can be generated from URDF, URDF+, or other formats, then provides preprocessed, derived information in modular JSON/YAML files that eliminate redundant computation. Second, while URDF+ and Extended URDF focus on capturing more complex kinematic structures within the specification, URDD addresses the broader challenge of organizing and standardizing the derived information that applications repeatedly compute from any robot description. Our modular directory structure enables incremental extension without affecting existing parsers, whereas specification-level extensions require updates to all downstream tools. Thus, URDD complements rather than competes with these format extensions, providing a unified preprocessing layer that could benefit from richer input specifications while solving the distinct problem of redundant derivation across robotics frameworks.

# B. Code Generation and Preprocessing Approaches

The concept of preprocessing robot descriptions to generate optimized code has been explored in several contexts. Frigerio et al. [5, 6] developed domain-specific languages and code generation tools (RobCoGen) for creating efficient kinematics and dynamics implementations. Their approach generates robot-specific code in multiple programming languages, demonstrating the value of offline preprocessing for runtime performance.

Similar preprocessing strategies have been applied to motion planning and control. Astudillo et al. [1] explored preprocessing techniques for fast nonlinear model predictive control, while motion primitive approaches have long utilized precomputed motion segments to accelerate planning algorithms. These works establish the broader principle that offline computation can significantly improve runtime performance in robotics applications.

Our work shares the preprocessing philosophy with these approaches but differs in scope and implementation strategy. While RobCoGen focuses specifically on generating executable kinematics and dynamics code for particular programming languages, URDD provides language-agnostic, structured data modules that can be consumed by any framework or programming language. Rather than generating specialized code, we precompute and organize derived information (DOF mappings, kinematic hierarchies, geometric approximations) in standardized formats that eliminate the need for repeated derivation while maintaining flexibility across different computational backends. This data-centric approach contrasts with the code generation paradigm, offering broader applicability at the cost of some runtime optimization that specialized generated code might provide.

# C. Simulation and Visualization Frameworks

Modern robotics frameworks increasingly require rich geometric and dynamic information for simulation and visualization. The Gazebo simulator [7] uses SDF (Simulation Description Format) for enhanced physics simulation capabilities, while MuJoCo [16] employs MJCF for efficient physics-based simulation. These specialized formats capture information beyond what URDF provides, but lack standardization across platforms.

Recent work has explored automatic generation of robot models for simulation. Lin et al. [8] developed AutoURDF for unsupervised robot modeling from point cloud data, while various researchers have created tools for converting between different description formats [15, 14]. However, these conversion approaches often result in information loss and format-specific limitations.

Unlike these simulation-specific formats and conversion tools, URDD provides a simulation-agnostic intermediate representation that can serve multiple backends simultaneously. Rather than converting between incompatible formats (often with information loss), our approach generates comprehensive derived data once and makes it available in standardized, parsable formats. This feature eliminates the need for format-specific converters and reduces the coupling between robot descriptions and particular simulation engines. Our web-based and Bevy-based visualization tools demonstrate this flexibility, showing how the same URDD can drive different rendering backends without modification.

# D. Geometric Processing and Collision Detection

Collision detection and geometric processing represent critical applications that require rich geometric information. Several researchers have developed specialized tools for

geometric approximation and collision checking. Courmar et al. [4] created Foam, a tool for spherical approximation of robot geometry, while Nechyporenko et al. [9] developed MorphIt for flexible spherical approximation supporting representation-driven adaptation.

These geometric processing tools typically require preprocessing of mesh data into simplified representations such as convex hulls, bounding volumes, and convex decompositions. However, this preprocessing is often performed repeatedly across different frameworks, leading to redundant computation and inconsistent results.

URDD directly addresses the redundancy problem identified in geometric processing workflows. Rather than each application independently computing convex hulls, bounding volumes, and collision-skip matrices, our mesh and link shape modules provide these geometric approximations in standardized formats that can be reused across frameworks. This design eliminates the repeated computation that tools like Foam and MorphIt perform, while ensuring consistency in geometric representations.

# III. UNIVERSAL ROBOT DESCRIPTION DIRECTORY

This section provides an overview of the Universal Robot Description Directory (URDD). We first discuss the overall structure, then examine several core sub-modules contained within the directory.

# A. URDD Structure

A URDD is organized as a hierarchical directory structure that groups together all derived robot information in a modular and extensible fashion. Figure 1 provides an overview of this structure. At the top level, the URDD contains a root directory that houses a set of subdirectories, or modules, each responsible for encoding a particular aspect of the robot's kinematic, geometric, or dynamic properties. Every module is stored in a standardized, human-readable format (JSON or YAML), ensuring that downstream applications can easily parse and reuse the information.

The root of the URDD also maintains a metadata file that records the robot's name and versioning information. This design supports both backward compatibility and incremental extension: new modules can be incorporated without affecting existing ones, while outdated modules can be flagged and updated in isolation. In practice, this approach eliminates the brittleness often encountered when augmenting monolithic specification formats such as XML-based URDF.

The URDD separates modules into logical categories. Some modules describe structural properties (e.g., link hierarchies, kinematic chains), others capture numerical mappings (e.g., degrees of freedom indices), while others contain precomputed geometric data (e.g., convex decompositions, bounding volumes).

# B. URDD Modules

As noted above, each URDD is composed of a collection of modules, each encoding a distinct aspect of a robot's structure, geometry, or dynamics in lightweight JSON and

YAML files. Here, we highlight several representative modules currently included in the URDD. For a comprehensive view of all modules, please see our documentation<sup>2</sup>.

URDF Module. This module preserves all information from the raw URDF specification but reforms it into lightweight, human-readable JSON and YAML files. By mirroring the original URDF in more accessible formats, it ensures full compatibility with existing tools while simplifying parsing and downstream use.

DOF Module. This module specifies the number of degrees of freedom (DOFs) of the robot and provides forward and inverse mappings between joint indices and DOF indices. Such mappings are critical for defining configuration vectors, supporting tasks like motion planning and optimization.

Connections Module. This module encodes the paths between all pairs of links in the kinematic tree. Each path is represented as a sequence of joints and links, enabling efficient traversal queries that support algorithms such as inverse kinematics or Jacobian construction.

Chain Module. This module specifies the parent-child hierarchy of the robot, listing for each link its parent joint and all associated child joints. The resulting hierarchy directly supports the construction of forward kinematics routines and other recursive computations.

Bounds Module. This module specifies lower and upper joint limits for each degree of freedom, enabling consistent use of configuration constraints across planning, control, and optimization routines.

Mesh Modules. This set of modules store original and derived mesh data for each link. Raw meshes are saved in common formats (.glb, .obj, .stl), alongside derived convex hulls and convex decompositions. Relative paths to these files are maintained in the module's JSON/YAML entries, ensuring portability. This structure facilitates reuse across visualization engines, physics simulators, and collision checkers.

Link Shapes Modules. This set of modules provides simplified geometric approximations, such as oriented bounding boxes and bounding spheres, computed both at the link level and for each element of a convex decomposition. In addition to purely geometric data, the modules include learned representations (e.g., neural networks that approximate the robot's self-collision state [11, 12]) as well as link distance statistics (such as mean, minimum, and maximum distances) that can be leveraged by self-collision algorithms [13]. The set also includes metadata identifying link pairs that can be safely skipped during self-collision checks, mirroring strategies employed in existing frameworks but stored here in a standardized, transferable format.

# IV. TOOLS FOR GENERATING AND INSPECTING URDD

While the URDD provides a standardized structure for organizing derived robot information, its practical value depends on the availability of tools that can generate and inspect these directories efficiently. To this end, we provide

![](images/decc7c4c6a44c476616cd3acb2e85ed6a339f112d992622ea4d5187d6b81038d.jpg)  
Fig. 1: Structure of the Universal Robot Description Directory (URDD). The URDD organizes derived robot information into modular subdirectories stored in JSON/YAML. Core modules include kinematic structure (chain, connections, DOF mappings), joint bounds, and preprocessed geometry (meshes, convex hulls, bounding volumes). Each module is version-tagged and independently extensible, enabling richer, reusable data for planning, control, and visualization without the redundancy of re-deriving information from raw URDFs.

an open-source software suite that automates the conversion of traditional URDFs into URDDs and enables interactive visualization of their contents. These tools are designed to reduce redundant preprocessing effort, facilitate debugging, and ensure that the derived modules remain transparent and accessible to developers.

# A. URDF to URDD Converter

The first tool we provide is a converter that automatically transforms a robot's URDF file into a fully populated URDD. The converter parses the minimal structural information encoded in the URDF, such as link definitions, joint types, and mesh file references, and expands it into the richer set of derived modules described in §III-B. This process includes automatically computing degrees of freedom mappings, establishing kinematic hierarchies, generating convex hulls and convex decompositions for collision geometry, and exporting meshes into multiple formats.

Our implementation is written in Rust and emphasizes

both efficiency and portability. The Rust code performs the URDF parsing, generates all module files in JSON and YAML formats, and stores accompanying mesh files (.glb, .obj, .stl) directly within the relevant module subdirectories. Importantly, the preprocessor also includes dedicated routines for automatically generating convex hulls and convex decompositions for every shape, ensuring that geometric simplifications are available in standardized formats for downstream collision checking and proximity queries.

Beyond batch generation, the Rust preprocessor provides an interactive, GUI-based tool, built on the Bevy game engine, that enables users to visually specify link-skip pairs for each shape type (e.g., convex hulls, oriented bounding boxes, convex decomposition elements). This functionality streamlines the creation of self-collision matrices by allowing users to directly inspect and refine which link pairs should be excluded from collision and proximity checks.

In addition to generating URDDs for individual robots, the converter supports batch processing across entire robot

![](images/572b557ce3912f68bb3c181dfdabddcd0c1145c60bb4248b583fb9023118174c.jpg)  
Fig. 2: Our software tools enable seamless combination of multiple URDDs. In this example, a Robotiq gripper (left) is attached to a Unitree Z1 arm (center), which is then mounted onto a Unitree B1 quadruped (right). The resulting composite URDD integrates the information from all three platforms into a single, unified directory.

repositories. This capability enables research groups and organizations to preprocess large collections of robot models at once, creating a consistent library of URDDs that can be shared and reused across projects. Each generated directory is self-contained, with relative file paths and version tags ensuring that URDDs remain portable across operating systems and computing environments.

Beyond preprocessing single robots, the converter also supports combining multiple URDDs into composite systems. For example, a gripper can be attached to the end of a manipulator arm, which in turn can be mounted on the back of a quadruped base, as illustrated in Figure 2. These attachment points are defined using any legal joint type, including fixed, revolute, prismatic, or floating joints. This functionality allows complex, multi-robot configurations to be constructed directly from existing URDDs without requiring manual edits to the underlying URDF files.

Together, these features position the URDF-to-URDD converter as a useful tool for adopting the URDD representation, allowing existing robot descriptions to be seamlessly converted into a richer, extensible format.

# B. URDD Inspection Tools

In addition to the converter, we provide a suite of inspection tools that enable developers to visualize, debug, and validate URDD outputs. These tools are designed to ensure transparency in the preprocessing stage and to simplify the process of integrating URDDs into diverse workflows. Two primary implementations are currently available.

First, a Rust-based visualization program leverages the Bevy game engine to render robot models and their associated derived shapes in real time. Users can load any URDD and interactively inspect meshes, convex hulls, convex decompositions, and bounding volumes (seen in Figure 3). The interface also supports toggling between different shape types, highlighting link hierarchies, and overlaying collision skip pairs, providing an intuitive means to verify the correctness of preprocessing routines. This tool is especially useful

![](images/9d2870a773e1d7a6a4549b20f460c88b7a5e022287d34f99d3d2060163fdaacc.jpg)  
Fig. 3: The Bevy-based graphics front-end powers a proximity visualization, enabling users to observe distances between pairs of link shapes. In this instance, the visualization shows the distance between two convex decomposition shapes.

![](images/8c6520bbb15ab5bd54fc9f7c8aa8ee47260833a202363709a0beb5d2bd1caa93.jpg)  
Fig. 4: In-browser visualization. a) Overall UI and visualization of the B1 robot. b) Oriented bounding boxes for each link. c) Bounding spheres for each link. d) Oriented bounding boxes for each element of the convex decomposition. e) Bounding spheres for each element of the convex decomposition. f) Convex hulls. g) Convex decomposition for each link.

during development, as it bridges the gap between raw text-based modules and their geometric meaning.

Second, we provide a lightweight web-based viewer implemented in JavaScript with Three.js (seen in Figure 4). This viewer reads directly from the URDD directory and renders robot models inside a browser, requiring no additional installation. By exposing URDD contents in an accessible, platform-independent environment, the web viewer makes it easy to share and validate robot resources across research groups or with collaborators who may not have access to the Rust toolchain. The viewer supports interactive features such as link highlighting, mesh type selection, and configuration-space exploration through simple slider controls.

Together, these inspection tools ensure that the URDD is not treated as a black-box data format, but rather as a transparent, verifiable resource. By making derived modules

easy to visualize and validate, they reduce the likelihood of silent preprocessing errors and encourage adoption of the URDD as a shared standard for robot description.

# V. EVALUATION

To evaluate the efficacy of the Universal Robot Description Directory (URDD) and its associated tools, we conducted a series of experiments across multiple robot platforms. The goal of these experiments is to demonstrate that URDDs can be generated efficiently, that they provide a compact yet expressive representation compared to traditional URDF files, and that they can be directly applied to downstream robotics tasks with minimal additional effort.

# A. URDF to URDD Timing

We first evaluate the efficiency of the URDF-to-URDD conversion process. Since the URDD framework is designed to eliminate redundant preprocessing by generating all necessary modules up front, it is important that this conversion step can be performed quickly, even for complex robot models. To assess this, we measured the runtime required to generate complete URDDs from a set of representative robots of varying size and complexity. This preprocessing and data collection was done on a MacBook Air laptop equipped with an Apple M3 processor and 32GB of RAM

We run this process on five simulated robot platforms: (1) Universal Robots  $\mathrm{UR5e^3}$ ; (2) A UFactory XArm7 $^4$ ; (3) A Unitree B1 $^5$ ; (4) An Orca hand gripper $^6$ ; and (5) A Unitree H1 $^7$ . The robot models outputted from this step via URDDs are all viewable in the browser visualization linked in the introduction.

Table I reports conversion times for five example platforms. Across these trials, the preprocessing consistently completed within seconds, with only modest variation depending on the complexity of the underlying meshes and the number of links and joints. These results indicate that the overhead of generating a URDD is negligible compared to the potential downstream savings, making it practical to preprocess large robot repositories in batch.

TABLE I: URDF-to-URDD conversion times for five example robots. We also list the number of degrees of freedom and number of links for each robot.  

<table><tr><td>Robot</td><td>Num. DOFs</td><td>Num. Links</td><td>Conversion Time (s)</td></tr><tr><td>UR5</td><td>6</td><td>11</td><td>25.6</td></tr><tr><td>XArm7</td><td>7</td><td>10</td><td>21.3</td></tr><tr><td>B1</td><td>12</td><td>35</td><td>60.0</td></tr><tr><td>Orca hand</td><td>17</td><td>55</td><td>90.5</td></tr><tr><td>H1</td><td>19</td><td>25</td><td>69.3</td></tr></table>

Overall, these results demonstrate that URDDs can be generated efficiently across a range of robot models, ensuring that the benefits of standardized preprocessing can be realized without imposing significant setup cost.

<sup>3</sup>https://www.universal-robots.com/products/ur5e/  
4https://www.ufactory.us/xarm  
<sup>5</sup>https://shop/unitree.com/products/unitree-b1  
<sup>6</sup>https://www.orcahand.com/  
<sup>7</sup>https://www.unitree.com/h1

# B. URDF vs. URDD Data Size

We next compare the information content of URDFs and URDDs. A URDF file typically encodes only the minimal structural properties of a robot (e.g., links, joints, inertial parameters), and while it may reference external mesh files, it omits many forms of derived data needed for downstream use. In contrast, a URDD explicitly stores this derived information in dedicated modules, alongside colocated meshes in multiple formats. As a result, URDDs occupy more disk space, but this increase reflects a richer and more immediately useful representation rather than redundancy.

Table II summarizes representative sizes for the same five robots specified in §V-A, showing raw URDFs, URDFs plus referenced meshes, URDDs without meshes, and URDDs with meshes. The key observation is that URDDs capture significantly more derived information, such as DOF mappings, kinematic hierarchies, convex decompositions, and link shape approximations, while still remaining reasonably lightweight.

TABLE II: URDF vs. URDD sizes for five example robots. URDDs store richer derived information while remaining compact.  

<table><tr><td></td><td>URDF
w/o meshes
(MB)</td><td>URDF
w/ meshes
(MB)</td><td>URDD
w/o meshes
(MB)</td><td>URDD
w/ meshes
(MB)</td></tr><tr><td>UR5</td><td>0.013</td><td>6.7</td><td>7.5</td><td>31.8</td></tr><tr><td>XArm7</td><td>0.017</td><td>2.1</td><td>8.0</td><td>17.3</td></tr><tr><td>B1</td><td>0.042</td><td>39.6</td><td>13.6</td><td>109.8</td></tr><tr><td>Orca hand</td><td>0.049</td><td>4.1</td><td>43.8</td><td>62.4</td></tr><tr><td>H1</td><td>0.028</td><td>33.1</td><td>25.8</td><td>112.8</td></tr></table>

Overall, these results show that URDDs expand the amount of accessible robot information far beyond what is provided by a URDF, while maintaining compactness and portability. We argue that, in many settings, the increase in size is outweighed by the benefit of storing precomputed modules that can be directly applied in planning, control, simulation, and visualization tasks.

# C. Forward kinematics analysis

Finally, we evaluate the practicality of URDDs by measuring how quickly a user can implement forward kinematics (FK), a fundamental capability in nearly all robotics applications. We tested this process using our URDD implementations in both Rust and Python. We treat FK as a "baseline milestone" for a robotics framework: once FK is available, other downstream capabilities such as Jacobian construction, inverse kinematics, or dynamics routines can naturally follow. Thus, the number of lines of code required to reach FK provides a useful proxy for how much preprocessing effort is pushed onto the user.

We compare our Rust and Python code to five open-source, commonly used robotics frameworks: (1) PyKDL; (2) Klampt; (3) Drake; (4) Isaac Sim; and (5) MuJoCo.

1) Methodology: To obtain a fair comparison across frameworks, we determined the number of lines of code

required to reach FK by back-tracing from the FK function call all the way to the initial parsing of the robot specification file. Specifically, we examined the source code of each framework and identified every line of code in the dependency chain between (1) parsing a specification file (e.g., URDF, MJCF, USD); and (2) the first callable FK function. This includes intermediate routines such as building kinematic chains, mapping DOFs to joint indices, and constructing hierarchical link structures. Importantly, our counts exclude the FK function itself and exclude generic fileParsing utilities. Only lines of code directly required along the FK dependency path are included.

2) Results: In the case of URDD, both the Rust and Python implementations required no additional lines beyond parsing. Because modules such as the chain and DOF modules already store the precomputed data needed for FK, simply loading these modules suffices to afford FK. Thus, the count of "0" lines for URDD in Table III reflects the fact that all necessary logic is contained in the URDD files themselves, leaving the user with no intermediate preprocessing burden. By contrast, frameworks such as Isaac Sim, MuJoCo, PyKDL, Klampt, and Drake must re-derive this information from raw specification files, resulting in significantly larger dependency paths.

Table III reports the approximate number of lines of code required for each framework. As shown, URDD-based implementations reduce the preprocessing burden to zero, while other frameworks typically require hundreds or even thousands of lines of supporting code before FK becomes available.

TABLE III: Approximate lines of code required to reach forward kinematics (FK) across different frameworks. Counts are obtained by back-tracing the dependency tree from FK to the specification file.  

<table><tr><td>Framework</td><td>Specification Type</td><td>Lines to FK</td></tr><tr><td>PyKDL</td><td>URDF</td><td>730</td></tr><tr><td>Drake</td><td>URDF</td><td>880</td></tr><tr><td>Klampt</td><td>URDF</td><td>315</td></tr><tr><td>Isaac Sim</td><td>USD</td><td>1892</td></tr><tr><td>MuJoCo</td><td>MJCF</td><td>3784</td></tr><tr><td>Custom Rust (Ours)</td><td>URDD</td><td>0</td></tr><tr><td>Custom Python (Ours)</td><td>URDD</td><td>0</td></tr></table>

This analysis underscores the value of the URDD: by precomputing and organizing the derived modules required for FK, it collapses the dependency chain to a single step: parsing the URDD. This dramatically lowers the barrier to entry for new robot models and provides a consistent foundation for building more advanced capabilities.

# VI. DISCUSSION

In this paper, we present the Universal Robot Description Directory (URDD) representation: a modular, extensible foundation for robot description that moves well beyond the minimalism of existing formats such as URDF. By structuring derived information into lightweight, human-readable modules, the URDD reduces redundant preprocessing, enables immediate access to core data structures, and simplifies

the implementation of downstream robotics functions. Our evaluation showed that URDDs can be generated efficiently, capture significantly more information than raw specification files, and reduce the barrier to entry for implementing fundamental capabilities such as forward kinematics.

A central strength of the URDD is its expandability. Because the directory is composed of independent submodules, new modules can be added incrementally without disrupting existing workflows. For example, future modules could encode precomputed Jacobians, motion primitive libraries, or even data-driven models such as learned dynamics approximators. The modular structure also facilitates domain-specific extensions: researchers interested in surgical robotics, aerial robotics, or multi-robot systems could all add tailored modules while preserving compatibility with the broader ecosystem. In this way, the URDD serves not only as a static representation but as an evolving framework that grows with the needs of the robotics community.

# A. Limitations and Future Directions

Despite its benefits, the URDD design introduces several challenges. One concern is scalability: as more modules are added, the size and complexity of each URDD may grow substantially, potentially leading to storage and parsing overhead. While our current evaluation suggests that URDDs remain lightweight, large-scale adoption across domains will require strategies to manage this growth.

A natural solution is to allow users to specify which modules are generated and stored for a particular robot. For example, a developer focused solely on kinematics may not need high-fidelity convex decompositions, while a researcher in simulation may prefer to include all geometric approximations. In addition, a clear mechanism for specifying module dependencies would further enhance usability. Certain applications may require particular modules (e.g., Jacobian computation depends on the chain and DOF modules) and these relationships should be encoded to guide both generation and downstream use.

Finally, as the ecosystem expands, standardized documentation and validation tools will be critical for ensuring consistency across modules developed by different groups. Our current inspection tools provide a starting point, but broader community engagement will be essential to establish conventions that keep the URDD both extensible and reliable.

In summary, the URDD represents a step toward shared, standardized robot descriptions that are both rich and adaptable. By embracing modularity and expandability, it lays the groundwork for a collaborative infrastructure that can evolve alongside the diverse and growing demands of robotics research and applications.

# REFERENCES

[1] Alejandro Astudillo, Joris Gillis, Wilm Decré, G. Pipeleers, and J. Swevers. Towards an open toolchain for fast nonlinear mpc for serial robots. IFAC-PapersOnLine, 2020. URL https:

//api_semanticscholar.org/CorpusId: 234955524.  
[2] Virgile Batto, Ludovic De Matteis, and Nicolas Mansard. Extended urdf: Accounting for parallel mechanism in robot description. ArXiv, abs/2504.04767, 2025. URL https://api_semanticscholar.org/CorpusId:277621649.  
[3] Matthew Chignoli, Jean-Jacques E. Slotine, Patrick M. Wensing, and Sangbae Kim. Urdf+: An enhanced urdf for robots with kinematic loops. 2024 IEEE-RAS 23rd International Conference on Humanoid Robots (Humanoids), pages 197-204, 2024. URL https://api-semanticscholar.org/CorpusId:274422649.  
[4] S. Coumar, Gilbert Chang, Nihar Kodkani, and Zachary Kingston. Foam: A tool for spherical approximation of robot geometry. ArXiv, abs/2503.13704, 2025. URL https://api-semanticscholar.org/CorpusId:277104323.  
[5] M. Frigerio, J. Buchli, and D. Caldwell. A domain specific language for kinematic models and fast implementations of robot dynamics algorithms. ArXiv, abs/1301.7190, 2013. URL https://api-semanticscholar.org/CorpusId: 16433563.  
[6] M. Frigerio, J. Buchli, D. Caldwell, and C. Semini. Robcogen: a code generator for efficient kinematics and dynamics of articulated robots, based on domain specific languages. In unknown, 2016. URL https://doi.org/10.6092/JOSER_2016_07_01_P36.  
[7] Nathan P. Koenig and A. Howard. Design and use paradigms for gazebo, an open-source multirobot simulator. 2004 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) (IEEE Cat. No.04CH37566), 3:2149-2154 vol.3, 2004. URL http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=1389727.  
[8] Jiong Lin, Lechen Zhang, Kwansoo Lee, Jialong Ning, Judah Goldfeder, and Hod Lipson. Autourdf: Unsupervised robot modeling from point cloud frames using cluster registration. 2025 IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR), pages 27628-27637, 2024. URL https://api-semanticscholar.org/CorpusId:274597896.  
[9] N. Nechyporenko, Yutong Zhang, Sean Campbell, and Alessandro Roncone. Morphit: Flexible spherical approximation of robot morphology for representation-driven adaptation. ArXiv, abs/2507.14061, 2025. URL https://api-semanticscholar.org/CorpusId:280047794.  
[10] M. Quigley. Ros: an open-source robot operating system. In IEEE International Conference on Robotics and Automation, 2009. URL http://www.cs.stanford.edu/people/ ang/papers/icraoss09-ROS.pdf.  
[11] Daniel Rakita, Bilge Mutlu, and Michael Gleicher.

RelaxedIK: Real-time synthesis of accurate and feasible robot arm motion. In Robotics: Science and Systems, volume 14, pages 26-30. Pittsburgh, PA, 2018.  
[12] Daniel Rakita, Haochen Shi, Bilge Mutlu, and Michael Gleicher. CollisionIK: A per-instant pose optimization method for generating robot motions with environment collision avoidance. In 2021 IEEE International Conference on Robotics and Automation (ICRA), pages 9995-10001. IEEE, 2021.  
[13] Daniel Rakita, Bilge Mutlu, and Michael Gleicher. Proxima: An approach for time or accuracy budgeted collision proximity queries. In Proceedings of Robotics: Science and Systems (RSS), 2022.  
[14] Maulshree Singh, Jayasekara Kapukotuwa, E. L. Gouveia, E. Fuenmayor, Yansong Qiao, Niall Murry, and D. Devine. Unity and ros as a digital and communication layer for digital twin application: Case study of robotic arm in a smart manufacturing cell. Sensors (Basel, Switzerland), 24, 2024. URL https://api-semanticscholar.org/CorpusId:272355830.  
[15] Rohan P. Singh, P. Gergondet, and F. Kanehiro. McMujoco: Simulating articulated robots with fsm controllers in mujoco. 2023 IEEE/SICE International Symposium on System Integration (SII), pages 1-5, 2022. URL https://api-semanticscholar.org/CorpusId:251979587.  
[16] E. Todorov, Tom Erez, and Yuval Tassa. Mujoco: A physics engine for model-based control. 2012 IEEE/RSJ International Conference on Intelligent Robots and Systems, pages 5026-5033, 2012. URL http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=6386109.  
[17] Daniella Tola and Peter Corke. Understanding urdf: A survey based on user experience. 2023 IEEE 19th International Conference on Automation Science and Engineering (CASE), pages 1-7, 2023. URL https://api-semanticscholar.org/CorpusId:257219951.  
[18] Daniella Tola and Peter Corke. Understanding urdf: A dataset and analysis. IEEE Robotics and Automation Letters, 9:4479-4486, 2023. URL https://api-semanticscholar.org/CorpusId:260351337.